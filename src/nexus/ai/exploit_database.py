#!/usr/bin/env python3
"""
NEXUS-AI Exploit Database System
A comprehensive, locally-maintained database of exploits for educational purposes
"""

import json
import os
import sqlite3
from datetime import datetime
from typing import Dict, List, Optional, Any
from pathlib import Path
import hashlib
import yaml

from ..core.config import get_config, get_logger
from ..security.security_validator_enhanced import get_security_validator

class ExploitDatabase:
    """
    Local exploit database system for educational penetration testing
    Provides curated, safe, and educational exploit resources
    """
    
    def __init__(self):
        self.config = get_config()
        self.logger = get_logger()
        self.security_validator = get_security_validator()
        
        # Database paths
        self.db_path = Path('data/exploits.db')
        self.db_path.parent.mkdir(exist_ok=True)
        
        # Exploit categories
        self.categories = {
            'authentication': ['ssh', 'ftp', 'telnet', 'rdp', 'smb'],
            'web_application': ['http', 'https', 'apache', 'nginx', 'iis'],
            'database': ['mysql', 'postgresql', 'mongodb', 'redis'],
            'container': ['docker', 'kubernetes', 'jenkins'],
            'network': ['dns', 'smtp', 'pop3', 'imap'],
            'storage': ['elasticsearch', 'cassandra', 'couchdb']
        }
        
        # Initialize database
        self._init_database()
        self._load_exploit_data()
        
        self.logger.info("ExploitDatabase initialized", 
                        db_path=str(self.db_path),
                        categories=len(self.categories))
    
    def _init_database(self):
        """Initialize SQLite database with exploit tables"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Create exploits table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS exploits (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    service TEXT NOT NULL,
                    category TEXT NOT NULL,
                    description TEXT,
                    difficulty TEXT,
                    risk_level TEXT,
                    code TEXT,
                    requirements TEXT,
                    usage_instructions TEXT,
                    safety_warnings TEXT,
                    created_date TEXT,
                    updated_date TEXT,
                    verified BOOLEAN DEFAULT FALSE,
                    tags TEXT
                )
            ''')
            
            # Create vulnerability_mappings table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS vulnerability_mappings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    cve_id TEXT,
                    service TEXT,
                    version_pattern TEXT,
                    exploit_id INTEGER,
                    FOREIGN KEY (exploit_id) REFERENCES exploits (id)
                )
            ''')
            
            # Create exploit_metadata table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS exploit_metadata (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    exploit_id INTEGER,
                    key TEXT,
                    value TEXT,
                    FOREIGN KEY (exploit_id) REFERENCES exploits (id)
                )
            ''')
            
            conn.commit()
            conn.close()
            
            self.logger.info("Database initialized successfully")
            
        except Exception as e:
            self.logger.error(f"Database initialization failed: {e}")
    
    def _load_exploit_data(self):
        """Load initial exploit data from JSON files"""
        try:
            # Load from data/exploits/ directory
            exploits_dir = Path('data/exploits')
            if not exploits_dir.exists():
                self._create_default_exploits()
                return
            
            for exploit_file in exploits_dir.glob('*.json'):
                self._load_exploit_from_file(exploit_file)
                
        except Exception as e:
            self.logger.error(f"Failed to load exploit data: {e}")
    
    def _create_default_exploits(self):
        """Create default exploit database with educational content"""
        default_exploits = [
            {
                'name': 'SSH Brute Force',
                'service': 'ssh',
                'category': 'authentication',
                'description': 'Educational SSH credential testing',
                'difficulty': 'easy',
                'risk_level': 'medium',
                'code': self._get_ssh_exploit_template(),
                'requirements': 'paramiko library',
                'usage_instructions': 'Use for educational purposes only',
                'safety_warnings': 'Only test on systems you own',
                'tags': 'ssh,brute_force,authentication'
            },
            {
                'name': 'MySQL Authentication Bypass',
                'service': 'mysql',
                'category': 'database',
                'description': 'MySQL authentication testing',
                'difficulty': 'medium',
                'risk_level': 'high',
                'code': self._get_mysql_exploit_template(),
                'requirements': 'mysql-connector-python',
                'usage_instructions': 'Educational database testing',
                'safety_warnings': 'Only test on authorized systems',
                'tags': 'mysql,database,authentication'
            },
            {
                'name': 'Apache Path Traversal',
                'service': 'apache',
                'category': 'web_application',
                'description': 'Apache path traversal vulnerability testing',
                'difficulty': 'medium',
                'risk_level': 'high',
                'code': self._get_apache_exploit_template(),
                'requirements': 'requests library',
                'usage_instructions': 'Test for path traversal vulnerabilities',
                'safety_warnings': 'Only test on authorized web servers',
                'tags': 'apache,web,path_traversal'
            }
        ]
        
        for exploit in default_exploits:
            self.add_exploit(exploit)
    
    def _get_ssh_exploit_template(self) -> str:
        """Get SSH exploit template"""
        return '''#!/usr/bin/env python3
"""
Educational SSH Exploit Template
For authorized penetration testing only
"""

import paramiko
import time
from typing import Optional

class SSHEducationalExploit:
    def __init__(self, target: str, port: int = 22):
        self.target = target
        self.port = port
        self.timeout = 10
        
    def test_credentials(self, username: str, password: str) -> bool:
        """Test SSH credentials (educational purpose only)"""
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(self.target, self.port, username, password, timeout=self.timeout)
            ssh.close()
            return True
        except:
            return False
    
    def run_educational_test(self):
        """Run educational SSH testing"""
        print(f"[EDUCATIONAL] Testing SSH on {self.target}:{self.port}")
        # Add educational testing logic here
        pass

def main():
    print("Educational SSH testing tool")
    # Add main logic here

if __name__ == "__main__":
    main()'''
    
    def _get_mysql_exploit_template(self) -> str:
        """Get MySQL exploit template"""
        return '''#!/usr/bin/env python3
"""
Educational MySQL Exploit Template
For authorized penetration testing only
"""

import mysql.connector
from typing import Optional

class MySQLEducationalExploit:
    def __init__(self, target: str, port: int = 3306):
        self.target = target
        self.port = port
        
    def test_connection(self, username: str, password: str) -> bool:
        """Test MySQL connection (educational purpose only)"""
        try:
            connection = mysql.connector.connect(
                host=self.target,
                port=self.port,
                user=username,
                password=password
            )
            connection.close()
            return True
        except:
            return False
    
    def run_educational_test(self):
        """Run educational MySQL testing"""
        print(f"[EDUCATIONAL] Testing MySQL on {self.target}:{self.port}")
        # Add educational testing logic here
        pass

def main():
    print("Educational MySQL testing tool")
    # Add main logic here

if __name__ == "__main__":
    main()'''
    
    def _get_apache_exploit_template(self) -> str:
        """Get Apache exploit template"""
        return '''#!/usr/bin/env python3
"""
Educational Apache Exploit Template
For authorized penetration testing only
"""

import requests
from urllib.parse import urljoin

class ApacheEducationalExploit:
    def __init__(self, target: str, port: int = 80):
        self.target = f"http://{target}:{port}"
        
    def test_path_traversal(self, payload: str) -> bool:
        """Test path traversal (educational purpose only)"""
        try:
            url = urljoin(self.target, payload)
            response = requests.get(url, timeout=10)
            return response.status_code == 200
        except:
            return False
    
    def run_educational_test(self):
        """Run educational Apache testing"""
        print(f"[EDUCATIONAL] Testing Apache on {self.target}")
        # Add educational testing logic here
        pass

def main():
    print("Educational Apache testing tool")
    # Add main logic here

if __name__ == "__main__":
    main()'''
    
    def add_exploit(self, exploit_data: Dict[str, Any]) -> bool:
        """Add a new exploit to the database"""
        try:
            # Validate exploit data
            validation = self._validate_exploit_data(exploit_data)
            if not validation['valid']:
                self.logger.error("Invalid exploit data", errors=validation['errors'])
                return False
            
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Insert exploit
            cursor.execute('''
                INSERT INTO exploits (
                    name, service, category, description, difficulty,
                    risk_level, code, requirements, usage_instructions,
                    safety_warnings, created_date, updated_date, verified, tags
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                exploit_data['name'],
                exploit_data['service'],
                exploit_data['category'],
                exploit_data.get('description', ''),
                exploit_data.get('difficulty', 'medium'),
                exploit_data.get('risk_level', 'medium'),
                exploit_data.get('code', ''),
                exploit_data.get('requirements', ''),
                exploit_data.get('usage_instructions', ''),
                exploit_data.get('safety_warnings', ''),
                datetime.now().isoformat(),
                datetime.now().isoformat(),
                exploit_data.get('verified', False),
                exploit_data.get('tags', '')
            ))
            
            conn.commit()
            conn.close()
            
            self.logger.info(f"Added exploit: {exploit_data['name']}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to add exploit: {e}")
            return False
    
    def search_exploits(self, service: str = None, category: str = None, 
                       difficulty: str = None, risk_level: str = None) -> List[Dict[str, Any]]:
        """Search exploits in the database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            query = "SELECT * FROM exploits WHERE 1=1"
            params = []
            
            if service:
                query += " AND service = ?"
                params.append(service)
            
            if category:
                query += " AND category = ?"
                params.append(category)
            
            if difficulty:
                query += " AND difficulty = ?"
                params.append(difficulty)
            
            if risk_level:
                query += " AND risk_level = ?"
                params.append(risk_level)
            
            cursor.execute(query, params)
            rows = cursor.fetchall()
            
            # Convert to dictionary format
            exploits = []
            for row in rows:
                exploit = {
                    'id': row[0],
                    'name': row[1],
                    'service': row[2],
                    'category': row[3],
                    'description': row[4],
                    'difficulty': row[5],
                    'risk_level': row[6],
                    'code': row[7],
                    'requirements': row[8],
                    'usage_instructions': row[9],
                    'safety_warnings': row[10],
                    'created_date': row[11],
                    'updated_date': row[12],
                    'verified': row[13],
                    'tags': row[14]
                }
                exploits.append(exploit)
            
            conn.close()
            return exploits
            
        except Exception as e:
            self.logger.error(f"Failed to search exploits: {e}")
            return []
    
    def get_exploit_by_id(self, exploit_id: int) -> Optional[Dict[str, Any]]:
        """Get exploit by ID"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("SELECT * FROM exploits WHERE id = ?", (exploit_id,))
            row = cursor.fetchone()
            
            conn.close()
            
            if row:
                return {
                    'id': row[0],
                    'name': row[1],
                    'service': row[2],
                    'category': row[3],
                    'description': row[4],
                    'difficulty': row[5],
                    'risk_level': row[6],
                    'code': row[7],
                    'requirements': row[8],
                    'usage_instructions': row[9],
                    'safety_warnings': row[10],
                    'created_date': row[11],
                    'updated_date': row[12],
                    'verified': row[13],
                    'tags': row[14]
                }
            
            return None
            
        except Exception as e:
            self.logger.error(f"Failed to get exploit: {e}")
            return None
    
    def get_exploits_for_service(self, service: str) -> List[Dict[str, Any]]:
        """Get all exploits for a specific service"""
        return self.search_exploits(service=service)
    
    def get_exploits_by_category(self, category: str) -> List[Dict[str, Any]]:
        """Get all exploits for a specific category"""
        return self.search_exploits(category=category)
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get database statistics"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Total exploits
            cursor.execute("SELECT COUNT(*) FROM exploits")
            total_exploits = cursor.fetchone()[0]
            
            # Exploits by service
            cursor.execute("SELECT service, COUNT(*) FROM exploits GROUP BY service")
            service_stats = dict(cursor.fetchall())
            
            # Exploits by category
            cursor.execute("SELECT category, COUNT(*) FROM exploits GROUP BY category")
            category_stats = dict(cursor.fetchall())
            
            # Exploits by difficulty
            cursor.execute("SELECT difficulty, COUNT(*) FROM exploits GROUP BY difficulty")
            difficulty_stats = dict(cursor.fetchall())
            
            conn.close()
            
            return {
                'total_exploits': total_exploits,
                'by_service': service_stats,
                'by_category': category_stats,
                'by_difficulty': difficulty_stats
            }
            
        except Exception as e:
            self.logger.error(f"Failed to get statistics: {e}")
            return {}
    
    def _validate_exploit_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Validate exploit data"""
        errors = []
        
        required_fields = ['name', 'service', 'category']
        for field in required_fields:
            if field not in data or not data[field]:
                errors.append(f"Missing required field: {field}")
        
        # Validate service
        if 'service' in data and data['service']:
            service = data['service'].lower()
            valid_services = []
            for category_services in self.categories.values():
                valid_services.extend(category_services)
            
            if service not in valid_services:
                errors.append(f"Invalid service: {service}")
        
        # Validate category
        if 'category' in data and data['category']:
            category = data['category'].lower()
            if category not in self.categories:
                errors.append(f"Invalid category: {category}")
        
        return {
            'valid': len(errors) == 0,
            'errors': errors
        }
    
    def _load_exploit_from_file(self, file_path: Path):
        """Load exploit from JSON file"""
        try:
            with open(file_path, 'r') as f:
                exploit_data = json.load(f)
            
            self.add_exploit(exploit_data)
            
        except Exception as e:
            self.logger.error(f"Failed to load exploit from {file_path}: {e}")

# Global instance
exploit_db = ExploitDatabase()
