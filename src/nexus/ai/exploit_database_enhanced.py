#!/usr/bin/env python3
"""
NEXUS-AI Enhanced Exploit Database System
Advanced SQLite-based database with performance optimizations and enhanced features
"""

import json
import os
import sqlite3
import threading
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path
import hashlib
import yaml
from contextlib import contextmanager

from ..core.config import get_config, get_logger
from ..security.security_validator_enhanced import get_security_validator

class EnhancedExploitDatabase:
    """
    Enhanced local exploit database system with performance optimizations
    Uses SQLite with advanced features for educational penetration testing
    """
    
    def __init__(self):
        self.config = get_config()
        self.logger = get_logger()
        self.security_validator = get_security_validator()
        
        # Database paths
        self.db_path = Path('data/exploits.db')
        self.db_path.parent.mkdir(exist_ok=True)
        
        # Threading lock for database operations
        self.db_lock = threading.Lock()
        
        # Cache for frequently accessed data
        self._cache = {}
        self._cache_ttl = 300  # 5 minutes
        
        # Exploit categories with enhanced metadata
        self.categories = {
            'authentication': {
                'services': ['ssh', 'ftp', 'telnet', 'rdp', 'smb'],
                'description': 'Authentication bypass and credential testing',
                'difficulty_range': ['easy', 'medium', 'high']
            },
            'web_application': {
                'services': ['http', 'https', 'apache', 'nginx', 'iis'],
                'description': 'Web application vulnerabilities and testing',
                'difficulty_range': ['easy', 'medium', 'high']
            },
            'database': {
                'services': ['mysql', 'postgresql', 'mongodb', 'redis'],
                'description': 'Database exploitation and testing',
                'difficulty_range': ['medium', 'high']
            },
            'container': {
                'services': ['docker', 'kubernetes', 'jenkins'],
                'description': 'Container and orchestration platform testing',
                'difficulty_range': ['medium', 'high']
            },
            'network': {
                'services': ['dns', 'smtp', 'pop3', 'imap'],
                'description': 'Network service exploitation',
                'difficulty_range': ['easy', 'medium']
            },
            'storage': {
                'services': ['elasticsearch', 'cassandra', 'couchdb'],
                'description': 'Storage and search engine testing',
                'difficulty_range': ['medium', 'high']
            }
        }
        
        # Initialize database with optimizations
        self._init_enhanced_database()
        self._load_default_exploits()
        
        self.logger.info("EnhancedExploitDatabase initialized", 
                        db_path=str(self.db_path),
                        categories=len(self.categories))
    
    @contextmanager
    def _get_db_connection(self):
        """Thread-safe database connection with optimizations"""
        with self.db_lock:
            conn = sqlite3.connect(self.db_path)
            # Enable WAL mode for better concurrency
            conn.execute("PRAGMA journal_mode=WAL")
            # Enable foreign keys
            conn.execute("PRAGMA foreign_keys=ON")
            # Set page size for better performance
            conn.execute("PRAGMA page_size=4096")
            # Enable memory-mapped I/O
            conn.execute("PRAGMA mmap_size=268435456")  # 256MB
            try:
                yield conn
            finally:
                conn.close()
    
    def _init_enhanced_database(self):
        """Initialize SQLite database with performance optimizations"""
        try:
            with self._get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Create exploits table with better indexing
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS exploits (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        service TEXT NOT NULL,
                        category TEXT NOT NULL,
                        description TEXT,
                        difficulty TEXT,
                        risk_level TEXT,
                        code TEXT,
                        requirements TEXT,
                        usage_instructions TEXT,
                        safety_warnings TEXT,
                        created_date TEXT,
                        updated_date TEXT,
                        verified BOOLEAN DEFAULT FALSE,
                        tags TEXT,
                        hash TEXT UNIQUE,
                        version INTEGER DEFAULT 1
                    )
                ''')
                
                # Create vulnerability_mappings table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS vulnerability_mappings (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        cve_id TEXT,
                        service TEXT,
                        version_pattern TEXT,
                        exploit_id INTEGER,
                        FOREIGN KEY (exploit_id) REFERENCES exploits (id) ON DELETE CASCADE
                    )
                ''')
                
                # Create exploit_metadata table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS exploit_metadata (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        exploit_id INTEGER,
                        key TEXT,
                        value TEXT,
                        FOREIGN KEY (exploit_id) REFERENCES exploits (id) ON DELETE CASCADE
                    )
                ''')
                
                # Create exploit_versions table for versioning
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS exploit_versions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        exploit_id INTEGER,
                        version INTEGER,
                        code TEXT,
                        changes TEXT,
                        created_date TEXT,
                        FOREIGN KEY (exploit_id) REFERENCES exploits (id) ON DELETE CASCADE
                    )
                ''')
                
                # Create indexes for better performance
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_exploits_service ON exploits(service)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_exploits_category ON exploits(category)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_exploits_difficulty ON exploits(difficulty)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_exploits_risk_level ON exploits(risk_level)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_exploits_verified ON exploits(verified)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_exploits_hash ON exploits(hash)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_vuln_mappings_cve ON vulnerability_mappings(cve_id)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_vuln_mappings_service ON vulnerability_mappings(service)')
                
                conn.commit()
                
            self.logger.info("Enhanced database initialized successfully")
            
        except Exception as e:
            self.logger.error(f"Enhanced database initialization failed: {e}")
    
    def _load_default_exploits(self):
        """Load default exploit data"""
        try:
            # Check if database is empty
            with self._get_db_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT COUNT(*) FROM exploits")
                count = cursor.fetchone()[0]
                
                if count == 0:
                    self._create_default_exploits()
                    self.logger.info("Created default exploits")
                else:
                    self.logger.info(f"Database already contains {count} exploits")
                
        except Exception as e:
            self.logger.error(f"Failed to load default exploits: {e}")
    
    def _create_default_exploits(self):
        """Create default exploit database with educational content"""
        default_exploits = [
            {
                'name': 'SSH Brute Force',
                'service': 'ssh',
                'category': 'authentication',
                'description': 'Educational SSH credential testing',
                'difficulty': 'easy',
                'risk_level': 'medium',
                'code': self._get_ssh_exploit_template(),
                'requirements': 'paramiko library',
                'usage_instructions': 'Use for educational purposes only',
                'safety_warnings': 'Only test on systems you own',
                'tags': 'ssh,brute_force,authentication'
            },
            {
                'name': 'MySQL Authentication Bypass',
                'service': 'mysql',
                'category': 'database',
                'description': 'MySQL authentication testing',
                'difficulty': 'medium',
                'risk_level': 'high',
                'code': self._get_mysql_exploit_template(),
                'requirements': 'mysql-connector-python',
                'usage_instructions': 'Educational database testing',
                'safety_warnings': 'Only test on authorized systems',
                'tags': 'mysql,database,authentication'
            },
            {
                'name': 'Apache Path Traversal',
                'service': 'apache',
                'category': 'web_application',
                'description': 'Apache path traversal vulnerability testing',
                'difficulty': 'medium',
                'risk_level': 'high',
                'code': self._get_apache_exploit_template(),
                'requirements': 'requests library',
                'usage_instructions': 'Test for path traversal vulnerabilities',
                'safety_warnings': 'Only test on authorized web servers',
                'tags': 'apache,web,path_traversal'
            }
        ]
        
        for exploit in default_exploits:
            self.add_exploit(exploit)
    
    def _get_ssh_exploit_template(self) -> str:
        """Get SSH exploit template"""
        return '''#!/usr/bin/env python3
"""
Educational SSH Exploit Template
For authorized penetration testing only
"""

import paramiko
import time
from typing import Optional

class SSHEducationalExploit:
    def __init__(self, target: str, port: int = 22):
        self.target = target
        self.port = port
        self.timeout = 10
        
    def test_credentials(self, username: str, password: str) -> bool:
        """Test SSH credentials (educational purpose only)"""
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(self.target, self.port, username, password, timeout=self.timeout)
            ssh.close()
            return True
        except:
            return False
    
    def run_educational_test(self):
        """Run educational SSH testing"""
        print(f"[EDUCATIONAL] Testing SSH on {self.target}:{self.port}")
        # Add educational testing logic here
        pass

def main():
    print("Educational SSH testing tool")
    # Add main logic here

if __name__ == "__main__":
    main()'''
    
    def _get_mysql_exploit_template(self) -> str:
        """Get MySQL exploit template"""
        return '''#!/usr/bin/env python3
"""
Educational MySQL Exploit Template
For authorized penetration testing only
"""

import mysql.connector
from typing import Optional

class MySQLEducationalExploit:
    def __init__(self, target: str, port: int = 3306):
        self.target = target
        self.port = port
        
    def test_connection(self, username: str, password: str) -> bool:
        """Test MySQL connection (educational purpose only)"""
        try:
            connection = mysql.connector.connect(
                host=self.target,
                port=self.port,
                user=username,
                password=password
            )
            connection.close()
            return True
        except:
            return False
    
    def run_educational_test(self):
        """Run educational MySQL testing"""
        print(f"[EDUCATIONAL] Testing MySQL on {self.target}:{self.port}")
        # Add educational testing logic here
        pass

def main():
    print("Educational MySQL testing tool")
    # Add main logic here

if __name__ == "__main__":
    main()'''
    
    def _get_apache_exploit_template(self) -> str:
        """Get Apache exploit template"""
        return '''#!/usr/bin/env python3
"""
Educational Apache Exploit Template
For authorized penetration testing only
"""

import requests
from urllib.parse import urljoin

class ApacheEducationalExploit:
    def __init__(self, target: str, port: int = 80):
        self.target = f"http://{target}:{port}"
        
    def test_path_traversal(self, payload: str) -> bool:
        """Test path traversal (educational purpose only)"""
        try:
            url = urljoin(self.target, payload)
            response = requests.get(url, timeout=10)
            return response.status_code == 200
        except:
            return False
    
    def run_educational_test(self):
        """Run educational Apache testing"""
        print(f"[EDUCATIONAL] Testing Apache on {self.target}")
        # Add educational testing logic here
        pass

def main():
    print("Educational Apache testing tool")
    # Add main logic here

if __name__ == "__main__":
    main()'''
    
    def _calculate_exploit_hash(self, exploit_data: Dict[str, Any]) -> str:
        """Calculate hash for exploit data to detect duplicates"""
        content = f"{exploit_data.get('name', '')}{exploit_data.get('service', '')}{exploit_data.get('code', '')}"
        return hashlib.sha256(content.encode()).hexdigest()
    
    def add_exploit(self, exploit_data: Dict[str, Any]) -> bool:
        """Add a new exploit to the database with enhanced validation"""
        try:
            # Validate exploit data
            validation = self._validate_exploit_data(exploit_data)
            if not validation['valid']:
                self.logger.error("Invalid exploit data", errors=validation['errors'])
                return False
            
            # Calculate hash
            exploit_hash = self._calculate_exploit_hash(exploit_data)
            
            with self._get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Check for duplicates
                cursor.execute("SELECT id FROM exploits WHERE hash = ?", (exploit_hash,))
                existing = cursor.fetchone()
                
                if existing:
                    self.logger.warning(f"Exploit already exists: {exploit_data['name']}")
                    return False
                
                # Insert exploit
                cursor.execute('''
                    INSERT INTO exploits (
                        name, service, category, description, difficulty,
                        risk_level, code, requirements, usage_instructions,
                        safety_warnings, created_date, updated_date, verified, tags, hash
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    exploit_data['name'],
                    exploit_data['service'],
                    exploit_data['category'],
                    exploit_data.get('description', ''),
                    exploit_data.get('difficulty', 'medium'),
                    exploit_data.get('risk_level', 'medium'),
                    exploit_data.get('code', ''),
                    exploit_data.get('requirements', ''),
                    exploit_data.get('usage_instructions', ''),
                    exploit_data.get('safety_warnings', ''),
                    datetime.now().isoformat(),
                    datetime.now().isoformat(),
                    exploit_data.get('verified', False),
                    exploit_data.get('tags', ''),
                    exploit_hash
                ))
                
                exploit_id = cursor.lastrowid
                
                # Add metadata if provided
                if 'metadata' in exploit_data:
                    for key, value in exploit_data['metadata'].items():
                        cursor.execute('''
                            INSERT INTO exploit_metadata (exploit_id, key, value)
                            VALUES (?, ?, ?)
                        ''', (exploit_id, key, str(value)))
                
                # Add vulnerability mappings if provided
                if 'cve_mappings' in exploit_data:
                    for cve_mapping in exploit_data['cve_mappings']:
                        cursor.execute('''
                            INSERT INTO vulnerability_mappings (cve_id, service, version_pattern, exploit_id)
                            VALUES (?, ?, ?, ?)
                        ''', (
                            cve_mapping.get('cve_id', ''),
                            cve_mapping.get('service', ''),
                            cve_mapping.get('version_pattern', ''),
                            exploit_id
                        ))
                
                conn.commit()
                
            # Clear cache
            self._clear_cache()
            
            self.logger.info(f"Added exploit: {exploit_data['name']} (ID: {exploit_id})")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to add exploit: {e}")
            return False
    
    def search_exploits(self, service: str = None, category: str = None, 
                       difficulty: str = None, risk_level: str = None,
                       verified_only: bool = False, limit: int = None) -> List[Dict[str, Any]]:
        """Search exploits with enhanced filtering and caching"""
        
        # Create cache key
        cache_key = f"search_{service}_{category}_{difficulty}_{risk_level}_{verified_only}_{limit}"
        
        # Check cache first
        if cache_key in self._cache:
            cache_time, cache_data = self._cache[cache_key]
            if (datetime.now().timestamp() - cache_time) < self._cache_ttl:
                return cache_data
        
        try:
            with self._get_db_connection() as conn:
                cursor = conn.cursor()
                
                query = "SELECT * FROM exploits WHERE 1=1"
                params = []
                
                if service:
                    query += " AND service = ?"
                    params.append(service)
                
                if category:
                    query += " AND category = ?"
                    params.append(category)
                
                if difficulty:
                    query += " AND difficulty = ?"
                    params.append(difficulty)
                
                if risk_level:
                    query += " AND risk_level = ?"
                    params.append(risk_level)
                
                if verified_only:
                    query += " AND verified = 1"
                
                query += " ORDER BY created_date DESC"
                
                if limit:
                    query += f" LIMIT {limit}"
                
                cursor.execute(query, params)
                rows = cursor.fetchall()
                
                # Convert to dictionary format
                exploits = []
                for row in rows:
                    exploit = {
                        'id': row[0],
                        'name': row[1],
                        'service': row[2],
                        'category': row[3],
                        'description': row[4],
                        'difficulty': row[5],
                        'risk_level': row[6],
                        'code': row[7],
                        'requirements': row[8],
                        'usage_instructions': row[9],
                        'safety_warnings': row[10],
                        'created_date': row[11],
                        'updated_date': row[12],
                        'verified': row[13],
                        'tags': row[14],
                        'hash': row[15],
                        'version': row[16]
                    }
                    exploits.append(exploit)
                
                # Cache the results
                self._cache[cache_key] = (datetime.now().timestamp(), exploits)
                
                return exploits
                
        except Exception as e:
            self.logger.error(f"Failed to search exploits: {e}")
            return []
    
    def get_exploit_by_id(self, exploit_id: int) -> Optional[Dict[str, Any]]:
        """Get exploit by ID with metadata and CVE mappings"""
        try:
            with self._get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Get main exploit data
                cursor.execute("SELECT * FROM exploits WHERE id = ?", (exploit_id,))
                row = cursor.fetchone()
                
                if not row:
                    return None
                
                exploit = {
                    'id': row[0],
                    'name': row[1],
                    'service': row[2],
                    'category': row[3],
                    'description': row[4],
                    'difficulty': row[5],
                    'risk_level': row[6],
                    'code': row[7],
                    'requirements': row[8],
                    'usage_instructions': row[9],
                    'safety_warnings': row[10],
                    'created_date': row[11],
                    'updated_date': row[12],
                    'verified': row[13],
                    'tags': row[14],
                    'hash': row[15],
                    'version': row[16]
                }
                
                # Get metadata
                cursor.execute("SELECT key, value FROM exploit_metadata WHERE exploit_id = ?", (exploit_id,))
                metadata = dict(cursor.fetchall())
                exploit['metadata'] = metadata
                
                # Get CVE mappings
                cursor.execute("SELECT cve_id, service, version_pattern FROM vulnerability_mappings WHERE exploit_id = ?", (exploit_id,))
                cve_mappings = []
                for cve_row in cursor.fetchall():
                    cve_mappings.append({
                        'cve_id': cve_row[0],
                        'service': cve_row[1],
                        'version_pattern': cve_row[2]
                    })
                exploit['cve_mappings'] = cve_mappings
                
                return exploit
                
        except Exception as e:
            self.logger.error(f"Failed to get exploit: {e}")
            return None
    
    def update_exploit(self, exploit_id: int, updates: Dict[str, Any]) -> bool:
        """Update an existing exploit with versioning"""
        try:
            with self._get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Get current exploit
                current_exploit = self.get_exploit_by_id(exploit_id)
                if not current_exploit:
                    return False
                
                # Store current version
                cursor.execute('''
                    INSERT INTO exploit_versions (exploit_id, version, code, changes, created_date)
                    VALUES (?, ?, ?, ?, ?)
                ''', (
                    exploit_id,
                    current_exploit['version'],
                    current_exploit['code'],
                    json.dumps(updates),
                    datetime.now().isoformat()
                ))
                
                # Build update query
                update_fields = []
                params = []
                
                for field, value in updates.items():
                    if field in ['name', 'description', 'difficulty', 'risk_level', 'code', 
                               'requirements', 'usage_instructions', 'safety_warnings', 'tags']:
                        update_fields.append(f"{field} = ?")
                        params.append(value)
                
                if update_fields:
                    update_fields.append("updated_date = ?")
                    update_fields.append("version = version + 1")
                    params.extend([datetime.now().isoformat(), exploit_id])
                    
                    query = f"UPDATE exploits SET {', '.join(update_fields)} WHERE id = ?"
                    cursor.execute(query, params)
                
                conn.commit()
                
            # Clear cache
            self._clear_cache()
            
            self.logger.info(f"Updated exploit ID {exploit_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to update exploit: {e}")
            return False
    
    def delete_exploit(self, exploit_id: int) -> bool:
        """Delete an exploit (soft delete with archiving)"""
        try:
            with self._get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Instead of hard delete, mark as archived
                cursor.execute("UPDATE exploits SET verified = 0 WHERE id = ?", (exploit_id,))
                
                conn.commit()
                
            # Clear cache
            self._clear_cache()
            
            self.logger.info(f"Archived exploit ID {exploit_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to delete exploit: {e}")
            return False
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get comprehensive database statistics"""
        try:
            with self._get_db_connection() as conn:
                cursor = conn.cursor()
                
                stats = {}
                
                # Basic counts
                cursor.execute("SELECT COUNT(*) FROM exploits")
                stats['total_exploits'] = cursor.fetchone()[0]
                
                cursor.execute("SELECT COUNT(*) FROM exploits WHERE verified = 1")
                stats['verified_exploits'] = cursor.fetchone()[0]
                
                # By service
                cursor.execute("SELECT service, COUNT(*) FROM exploits GROUP BY service")
                stats['by_service'] = dict(cursor.fetchall())
                
                # By category
                cursor.execute("SELECT category, COUNT(*) FROM exploits GROUP BY category")
                stats['by_category'] = dict(cursor.fetchall())
                
                # By difficulty
                cursor.execute("SELECT difficulty, COUNT(*) FROM exploits GROUP BY difficulty")
                stats['by_difficulty'] = dict(cursor.fetchall())
                
                # By risk level
                cursor.execute("SELECT risk_level, COUNT(*) FROM exploits GROUP BY risk_level")
                stats['by_risk_level'] = dict(cursor.fetchall())
                
                # Database size
                db_size = self.db_path.stat().st_size
                stats['database_size_mb'] = round(db_size / (1024 * 1024), 2)
                
                # Recent activity
                cursor.execute("""
                    SELECT COUNT(*) FROM exploits 
                    WHERE created_date > datetime('now', '-7 days')
                """)
                stats['recent_exploits'] = cursor.fetchone()[0]
                
                return stats
                
        except Exception as e:
            self.logger.error(f"Failed to get statistics: {e}")
            return {}
    
    def _clear_cache(self):
        """Clear the cache"""
        self._cache.clear()
    
    def _validate_exploit_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Enhanced validation for exploit data"""
        errors = []
        
        required_fields = ['name', 'service', 'category']
        for field in required_fields:
            if field not in data or not data[field]:
                errors.append(f"Missing required field: {field}")
        
        # Validate service
        if 'service' in data and data['service']:
            service = data['service'].lower()
            valid_services = []
            for category_info in self.categories.values():
                valid_services.extend(category_info['services'])
            
            if service not in valid_services:
                errors.append(f"Invalid service: {service}")
        
        # Validate category
        if 'category' in data and data['category']:
            category = data['category'].lower()
            if category not in self.categories:
                errors.append(f"Invalid category: {category}")
        
        # Validate difficulty
        if 'difficulty' in data and data['difficulty']:
            difficulty = data['difficulty'].lower()
            valid_difficulties = ['easy', 'medium', 'high']
            if difficulty not in valid_difficulties:
                errors.append(f"Invalid difficulty: {difficulty}")
        
        # Validate risk level
        if 'risk_level' in data and data['risk_level']:
            risk_level = data['risk_level'].lower()
            valid_risk_levels = ['low', 'medium', 'high', 'critical']
            if risk_level not in valid_risk_levels:
                errors.append(f"Invalid risk level: {risk_level}")
        
        return {
            'valid': len(errors) == 0,
            'errors': errors
        }
    
    def backup_database(self, backup_path: str = None) -> bool:
        """Create a backup of the database"""
        try:
            if not backup_path:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_path = f"data/exploits_backup_{timestamp}.db"
            
            backup_path = Path(backup_path)
            backup_path.parent.mkdir(exist_ok=True)
            
            with self._get_db_connection() as conn:
                backup_conn = sqlite3.connect(backup_path)
                conn.backup(backup_conn)
                backup_conn.close()
            
            self.logger.info(f"Database backed up to: {backup_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to backup database: {e}")
            return False
    
    def optimize_database(self) -> bool:
        """Optimize the database for better performance"""
        try:
            with self._get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Analyze tables for better query planning
                cursor.execute("ANALYZE")
                
                # Vacuum to reclaim space
                cursor.execute("VACUUM")
                
                # Rebuild indexes
                cursor.execute("REINDEX")
                
                conn.commit()
            
            self.logger.info("Database optimized successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to optimize database: {e}")
            return False

# Global instance - lazy initialization
_enhanced_exploit_db_instance = None

def get_enhanced_exploit_db():
    """Get the global enhanced exploit database instance (lazy initialization)"""
    global _enhanced_exploit_db_instance
    if _enhanced_exploit_db_instance is None:
        _enhanced_exploit_db_instance = EnhancedExploitDatabase()
    return _enhanced_exploit_db_instance

# For backward compatibility
enhanced_exploit_db = get_enhanced_exploit_db
